
# Aggregation
- process data records and return computed results group values from multiple documents together can perform a variety of operations on the grouped data to return a single result.
- In SQL count(*) and with group by is an equivalent of mongodb aggregation.


## MongoDB Aggregation Expressions

| Expression | Description      | Example              |
|------------|------------------------|---------|
| $sum       | Sums up the defined value from all documents in the collection.                        | `db.myCollection1.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : "$likes"}}}])` |
| $avg       | Calculates the average of all given values from all documents in the collection.       | `db.myCollection1.aggregate([{$group : {_id : "$by_user", num_tutorial : {$avg : "$likes"}}}])` |
| $min       | Gets the minimum of the corresponding values from all documents in the collection.     | `db.myCollection1.aggregate([{$group : {_id : "$by_user", num_tutorial : {$min : "$likes"}}}])` |
| $max       | Gets the maximum of the corresponding values from all documents in the collection.     | `db.myCollection1.aggregate([{$group : {_id : "$by_user", num_tutorial : {$max : "$likes"}}}])` |
| $push      | Inserts the value to an array in the resulting document.                               | `db.myCollection1.aggregate([{$group : {_id : "$by_user", url : {$push: "$url"}}}])`            |
| $addToSet  | Inserts the value to an array in the resulting document but does not create duplicates.| `db.myCollection1.aggregate([{$group : {_id : "$by_user", url : {$addToSet : "$url"}}}])`       |
| $first     | Gets the first document from the source documents according to the grouping.           | `db.myCollection1.aggregate([{$group : {_id : "$by_user", first_url : {$first : "$url"}}}])`    |
| $last      | Gets the last document from the source documents according to the grouping.            | `db.myCollection1.aggregate([{$group : {_id : "$by_user", last_url : {$last : "$url"}}}])`      |


## Pipeline
- In UNIX command, shell pipeline means the possibility to execute an operation on some input and use the output as the input for the next command and so on.
- MongoDB also supports same concept in aggregation framework. 
- There is a set of possible stages and each of those take a set of documents as an input and produces a resulting set of documents (or the final resulting JSON document at the end of the pipeline). 
- These can then in turn be used for the next stage and so on.

## Following are the possible stages in aggregation framework -
| Function     | Description     | Example     |
|--------------|----------------------------------|---------------------------------|
| $match       | Filters the documents to pass only the documents that match the specified condition(s) to the next pipeline stage. | `db.myCollection1.aggregate([{$match: {status: "active"}}])`    |
| $group       | Groups input documents by the specified _id expression and for each distinct grouping, outputs a document.      | `db.myCollection1.aggregate([{$group: {_id: "$by_user", totalLikes: {$sum: "$likes"}}}])`   |
| $sort        | Sorts all input documents and returns them to the pipeline in sorted order.   | `db.myCollection1.aggregate([{$sort: {createdAt: -1}}])`      |
| $project     | Reshapes each document in the stream, such as by adding new fields or removing existing fields.        | `db.myCollection1.aggregate([{$project: {name: 1, status: 1}}])`              |
| $push        | Adds an element to an array in the resulting document.   | `db.myCollection1.aggregate([{$group: {_id: "$by_user", urls: {$push: "$url"}}}])`    |
| $unwind      | Deconstructs an array field from the input documents to output a document for each element.    | `db.myCollection1.aggregate([{$unwind: "$items"}])`   |
| $addToSet    | Adds elements to an array in the resulting document but does not create duplicates. | `db.myCollection1.aggregate([{$group: {_id: "$by_user", uniqueTags: {$addToSet: "$tags"}}}])`    |
| $size        | Returns the size of an array.    | `db.myCollection1.aggregate([{$project: {name: 1, tagsCount: {$size: "$tags"}}}])`    |
| $limit       | Limits the number of documents passed to the next stage in the pipeline.   | `db.myCollection1.aggregate([{$limit: 5}])`      |
| $skip   | Skips the first n documents and passes the remaining documents to the next stage in the pipeline.   | `db.myCollection1.aggregate([{$skip: 10}])`         |
| $filter      | Selects a subset of an array to return based on the specified condition.  | `db.myCollection1.aggregate([{$project: {items: {$filter: {input: "$items", as: "item", cond: {$gte: ["$$item.quantity", 2]}}}}}])` |
| $addFields   | Adds new fields to documents.   | `db.myCollection1.aggregate([{$addFields: {totalSpent: {$sum: "$orders.amount"}}}])`     |


### $match
- The $match stage is similar to the query used as the first argument in .find(). 
- It filters documents based onspecified conditions.
- Syntax
	- { $match: { <query> } }
- Example
```js
db.products.aggregate([
{ $match: { company: "64c23350e32f4a51b19b9235" } }
]);
```

### $group
- The $group stage groups documents by specified fields and performs aggregate operations on grouped 
data
```js
{
$group:
	{
		_id: <expression>, // Group key
		<field1>: { <accumulator1> : <expression1> },
	}
}

db.products.aggregate([
{ $group: { _id: { comp: "$company" }, totalProducts: { $sum: 1 } } }]);

//This groups products by company and calculates the total number of products for each company.
//The $group stage can calculate various aggregate values within grouped data.

db.products.aggregate([
{ $group: {
_id: { comp: "$company" },
totalPrice: { $sum: "$price" },
totalProducts: { $sum: 1 },
averagePrice:     { $avg: "$price" }
}}
]);
```

### $sort
```js
//syntax
{ $sort: { <field>: <order> } }

//example
db.products.aggregate([{ $sort: { totalProducts: 1 } }]);
```

### $project
The $project stage reshapes documents, includes or excludes fields, and performs operations on fields.
```js
//syntax
{ $project: { <field1>: <expression1>, ... } }

//example
db.products.aggregate([
{ $project: { name: 1, discountedPrice: { $subtract: ["$price", 5] } } }
]);

//Projects the name field and calculates a discountedPrice field by subtracting 5 from the price.
//$sum, $subtract, $multiply, $avg, etc. are types of expression operator.
```

### $push
The $push stage adds elements to an array field within documents.
```js
//syntax
{ $push: <expression> }

//example
db.products.aggregate([
{ $group: { _id: { company: "$company" }, products: { $push: "$name" } } }
]);
```

### $unwind
The $unwind stage deconstructs an array field and produces multiple documents.
```js
//syntax
{ $unwind: <array> }

//example
db.products.aggregate([
{ $unwind: "$colors" },
{ $group: { _id: { company: "$company" }, products: { $push: "$colors" } } }
]);

//Deconstructs the colors array field, groups products by company, and creates an array of colors for each company.
```

### $addToSet
The $addToSet stage adds elements to an array field while preventing duplicates.
```js
db.products.aggregate([
{ $unwind: "$colors" },
{ $group: {
_id: { company: "$company" },
products: { $addToSet: "$colors" }
} }
])

//Groups products by company and creates an array of unique colors for each company.
```

### $size
The $size stage calculates the length of an array field.
```js
//syntax
{ $size: <array> }

//example
db.products.aggregate([
{ $project: { name: 1, numberOfColors: { $size: "$colors" } } }
]);

//Projects the name field and calculates the number of colors in the colors array.
```

### $limit and $skip
The $limit and $skip stages are useful for pagination, limiting, and skipping results.
```js
//syntax
{   $limit: <positive integer> }

//example
db.products.aggregate([
{ $skip: 10 },
{ $limit: 10 }
]);
```

### $filter
The $filter stage filters elements of an array based on specified conditions.

```js
$project: {
  <field>: {
    $filter: {
      input: '$<array>’,
      as: '<variable>’
      cond: <expression>
    }
  }
}
```
                         
### $addFields
The $addFields stage adds new fields to documents in a cleaner way compared to $project.
```js
//syntax
{ $addFields: { <field1>: <expression1>, ... } }

//example
db.products.aggregate([
{ $addFields: { discountedPrice: { $subtract: ["$price", 5] } } }
]);

```


