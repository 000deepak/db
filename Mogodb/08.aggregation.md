
## Aggregation
- process data records and return computed results group values from multiple documents together can perform a variety of operations on the grouped data to return a single result.
- In SQL count(*) and with group by is an equivalent of mongodb aggregation.

----------------------------


# MongoDB Aggregation Expressions

| Expression | Description      | Example              |
|------------|------------------------|---------|
| $sum       | Sums up the defined value from all documents in the collection.                        | `db.myCollection1.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : "$likes"}}}])` |
| $avg       | Calculates the average of all given values from all documents in the collection.       | `db.myCollection1.aggregate([{$group : {_id : "$by_user", num_tutorial : {$avg : "$likes"}}}])` |
| $min       | Gets the minimum of the corresponding values from all documents in the collection.     | `db.myCollection1.aggregate([{$group : {_id : "$by_user", num_tutorial : {$min : "$likes"}}}])` |
| $max       | Gets the maximum of the corresponding values from all documents in the collection.     | `db.myCollection1.aggregate([{$group : {_id : "$by_user", num_tutorial : {$max : "$likes"}}}])` |
| $push      | Inserts the value to an array in the resulting document.                               | `db.myCollection1.aggregate([{$group : {_id : "$by_user", url : {$push: "$url"}}}])`            |
| $addToSet  | Inserts the value to an array in the resulting document but does not create duplicates.| `db.myCollection1.aggregate([{$group : {_id : "$by_user", url : {$addToSet : "$url"}}}])`       |
| $first     | Gets the first document from the source documents according to the grouping.           | `db.myCollection1.aggregate([{$group : {_id : "$by_user", first_url : {$first : "$url"}}}])`    |
| $last      | Gets the last document from the source documents according to the grouping.            | `db.myCollection1.aggregate([{$group : {_id : "$by_user", last_url : {$last : "$url"}}}])`      |


## Pipeline
- In UNIX command, shell pipeline means the possibility to execute an operation on some input and use the output as the input for the next command and so on.
- MongoDB also supports same concept in aggregation framework. 
- There is a set of possible stages and each of those take a set of documents as an input and produces a resulting set of documents (or the final resulting JSON document at the end of the pipeline). 
- These can then in turn be used for the next stage and so on.

## Following are the possible stages in aggregation framework -
- $limit      
	- This limits the amount of documents to look at, by the given number starting from the current positions.
- $skip       
	- With this, it is possible to skip forward in the list of documents for a given amount of documents.
- $sort       
	- Sorts the documents.
- $project    
	- Used to select some specific fields from a collection.
- $group      
	- This does the actual aggregation as discussed above.
- $match      
	- This is a filtering operation and thus this can reduce the amount of documents that are given as input to the next stage.
- $unwind     
	- This is used to unwind document that are using arrays. When using an array, the data is kind of pre-joined and this operation will be undone with this to have individual documents again. Thus with this stage we will increase the amount of documents for the next stage.
---------------------------------


### $match
- The $match stage is similar to the query used as the first argument in .find(). 
- It filters documents based onspecified conditions.
- Syntax
	- { $match: { <query> } }
- Example
```js
db.products.aggregate([
{ $match: { company: "64c23350e32f4a51b19b9235" } }
]);
```

### $group
- The $group stage groups documents by specified fields and performs aggregate operations on grouped 
data
```js
{
$group:
	{
		_id: <expression>, // Group key
		<field1>: { <accumulator1> : <expression1> },
	}
}

db.products.aggregate([
{ $group: { _id: { comp: "$company" }, totalProducts: { $sum: 1 } } }]);

//This groups products by company and calculates the total number of products for each company.
//The $group stage can calculate various aggregate values within grouped data.

db.products.aggregate([
{ $group: {
_id: { comp: "$company" },
totalPrice: { $sum: "$price" },
totalProducts: { $sum: 1 },
averagePrice:     { $avg: "$price" }
}}
]);
```

### $sort
```js
//syntax
{ $sort: { <field>: <order> } }

//example
db.products.aggregate([{ $sort: { totalProducts: 1 } }]);
```

### $project
```js
The $project stage reshapes documents, includes or excludes fields, and performs operations on 
fields.
{ $project: { <field1>: <expression1>, ... } }
db.products.aggregate([
{ $project: { name: 1, discountedPrice: { $subtract: ["$price", 5] } } }
]);
Projects the name field and calculates a discountedPrice field by subtracting 5 from the price.
$sum, $subtract, $multiply, $avg, etc. are types of expression operator.
```

### $push
```js
The $push stage adds elements to an array field within documents.
{ $push: <expression> }
db.products.aggregate([
{ $group: { _id: { company: "$company" }, products: { $push: "$name" } } }
]);
```

### $unwind
```js
The $unwind stage deconstructs an array field and produces multiple documents.
{ $unwind: <array> }
db.products.aggregate([
{ $unwind: "$colors" },
{ $group: { _id: { company: "$company" }, products: { $push: "$colors" } } }
]);
Deconstructs the colors array field, groups products by company, and creates an array of colors for 
each
company.
```

### $addToSet
```js
The $addToSet stage adds elements to an array field while preventing duplicates.
db.products.aggregate([
{ $unwind: "$colors" },
{ $group: {
_id: { company: "$company" },
products: { $addToSet: "$colors" }
} }
])
Groups products by company and creates an array of unique colors for each company.
```

### $size
```js
The $size stage calculates the length of an array field.
{ $size: <array> }
db.products.aggregate([
{ $project: { name: 1, numberOfColors: { $size: "$colors" } } }
]);
Projects the name field and calculates the number of colors in the colors array.
```

### $limit and $skip
```js
The $limit and $skip stages are useful for pagination, limiting, and skipping results.
{   $limit: <positive integer> }
db.products.aggregate([
{ $skip: 10 },
{ $limit: 10 }
]);
```

### $filter
```js
The $filter stage filters elements of an array based on specified conditions.

$project: {
  <field>: {
    $filter: {
      input: '$<array>’,
      as: '<variable>’
      cond: <expression>
    }
  }
}
```
                         
### $addFields
```js
The $addFields stage adds new fields to documents in a cleaner way compared to $project.
{ $addFields: { <field1>: <expression1>, ... } }
db.products.aggregate([
{ $addFields: { discountedPrice: { $subtract: ["$price", 5] } } }
]);

```


